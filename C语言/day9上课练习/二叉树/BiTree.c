#include "BiTree.h"

//层次建树
void buildBinaryTree(pNode_t* treeRoot, pQueue_t* queHead, pQueue_t* queTail, ElemType val)
{
	//给树结点申请空间
	pNode_t treeNew = (pNode_t)calloc(1, sizeof(Node_t));
	treeNew->c = val;
	pQueue_t queNew = (pQueue_t)calloc(1, sizeof(Queue_t));
	queNew->insertPos = treeNew;
	pQueue_t queCur;
	if (NULL == *treeRoot)
	{
		*treeRoot = treeNew;
		*queHead = queNew;
		*queTail = queNew;
	}
	else {
		//入队
		(*queTail)->pnext = queNew;
		*queTail = queNew;
		//判断某个树结点的左孩子是否为空
		if (NULL == (*queHead)->insertPos->left)
		{
			(*queHead)->insertPos->left = treeNew;
		}
		//判断某个树结点的右孩子是否为空
		else if (NULL == (*queHead)->insertPos->right)
		{
			(*queHead)->insertPos->right = treeNew;
			//当某个树结点左右孩子都有了就出队
			queCur = *queHead;
			*queHead = queCur->pnext;
			free(queCur);
			queCur = NULL;
		}
	}
}


//前序遍历，深度优先遍历
void preOrder(pNode_t treeRoot)
{
	if (treeRoot)
	{
		putchar(treeRoot->c);
		preOrder(treeRoot->left);
		preOrder(treeRoot->right);
	}
}

//中序遍历
void midOrder(pNode_t treeRoot)
{
	if (treeRoot)
	{
		midOrder(treeRoot->left);
		putchar(treeRoot->c);
		midOrder(treeRoot->right);
	}
}

//后序遍历
void postOrder(pNode_t treeRoot)
{
	if (treeRoot)
	{
		postOrder(treeRoot->left);
		postOrder(treeRoot->right);
		putchar(treeRoot->c);
	}
}